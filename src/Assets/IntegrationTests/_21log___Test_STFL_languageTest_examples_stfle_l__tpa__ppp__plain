Testcase 21
Test/STFL.language Test/examples.stfl e -l --tpa --ppp --plain

Warning:
  While checking the totality of function "abstract":
    Following calls will fall through:
      abstract(("Bool" (type typeSet)))
      abstract(("Int" (type typeSet)))
  While checking the totality of function "equate":
    Following calls will fall through:
      equate(type, type)
  
Property Preservation holds for given examples                                  
Property successfull
# Property Preservation proven by failing predicate with assignment {e0 --> True}:
  # Success: e0 :: T
  # Failed: e0 → e1
# e0 → e1 failed because: 
  While trying to proof that (→) is applicable to "True":
    Not a single rule matched:
    While trying to intepret the rule EvalCtx with True:
      Evaluation contexts only searching within a parse tree and don't handle literals
    While trying to intepret the rule EvalPlus with True:
      :
        FT: Could not pattern match '"True"' over 'n1 "+" n2'
    While trying to intepret the rule EvalAscrBool with True:
      :
        FT: Could not pattern match '"True"' over 'b "::" "Bool"'
    While trying to intepret the rule EvalAscrInt with True:
      :
        FT: Could not pattern match '"True"' over 'i "::" "Int"'
    While trying to intepret the rule EvalParens with True:
      :
        FT: Could not pattern match '"True"' over '"(" e ")"'
    While trying to intepret the rule EvalIfTrue with True:
      :
        FT: Could not pattern match '"True"' over '"If" "True" "Then" e1 "Else" e2'
    While trying to intepret the rule EvalIfFalse with True:
      :
        FT: Could not pattern match '"True"' over '"If" "False" "Then" e1 "Else" e2'
    While trying to intepret the rule EvalLamApp with True:
      :
        FT: Could not pattern match '"True"' over '("(" "\\" var ":" type "." e ")") arg'
Property successfull
# Property Preservation proven by failing predicate with assignment {e0 --> False}:
  # Success: e0 :: T
  # Failed: e0 → e1
# e0 → e1 failed because: 
  While trying to proof that (→) is applicable to "False":
    Not a single rule matched:
    While trying to intepret the rule EvalCtx with False:
      Evaluation contexts only searching within a parse tree and don't handle literals
    While trying to intepret the rule EvalPlus with False:
      :
        FT: Could not pattern match '"False"' over 'n1 "+" n2'
    While trying to intepret the rule EvalAscrBool with False:
      :
        FT: Could not pattern match '"False"' over 'b "::" "Bool"'
    While trying to intepret the rule EvalAscrInt with False:
      :
        FT: Could not pattern match '"False"' over 'i "::" "Int"'
    While trying to intepret the rule EvalParens with False:
      :
        FT: Could not pattern match '"False"' over '"(" e ")"'
    While trying to intepret the rule EvalIfTrue with False:
      :
        FT: Could not pattern match '"False"' over '"If" "True" "Then" e1 "Else" e2'
    While trying to intepret the rule EvalIfFalse with False:
      :
        FT: Could not pattern match '"False"' over '"If" "False" "Then" e1 "Else" e2'
    While trying to intepret the rule EvalLamApp with False:
      :
        FT: Could not pattern match '"False"' over '("(" "\\" var ":" type "." e ")") arg'
Property successfull
# Property Preservation statisfied with assignment {T --> Bool, e0 --> If True Then False Else True, e1 --> False}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool                False : bool                True : bool                T1 = Bool = T2
    --------------- [Tbool]    ---------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]
    {} ⊢ True, Bool            {} ⊢ False, Bool            {} ⊢ True, Bool            Bool == Bool
    --------------------------------------------------------------------------------------------------- [TIf]
    {} ⊢ If True Then False Else True, Bool
    --------------------------------------------------------------------------------------------- [TEmptyCtx]
    If True Then False Else True :: Bool
  
  # Predicate satisfied:
  # e0 → e1
  
    ------------------------------------ [EvalIfTrue]
    If True Then False Else True → False
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  False : bool
  ---------------- [Tbool]
  {} ⊢ False, Bool
  ------------------------ [TEmptyCtx]
  False :: Bool
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Bool, e0 --> If ( If True Then False Else True ) Then False Else True, e1 --> If ( False ) Then False Else True}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool                False : bool                True : bool                T1 = Bool = T2                                                                    
    --------------- [Tbool]    ---------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]                                                           
    {} ⊢ True, Bool            {} ⊢ False, Bool            {} ⊢ True, Bool            Bool == Bool                                                                      
    --------------------------------------------------------------------------------------------------- [TIf]                                                           
    {} ⊢ If True Then False Else True, Bool                                                                      False : bool                True : bool                T1 = Bool = T2
    ----------------------------------------------------------------------------------------------- [TParens]    ---------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]
    {} ⊢ ( If True Then False Else True ), Bool                                                                  {} ⊢ False, Bool            {} ⊢ True, Bool            Bool == Bool
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [TIf]
    {} ⊢ If ( If True Then False Else True ) Then False Else True, Bool
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [TEmptyCtx]
    If ( If True Then False Else True ) Then False Else True :: Bool
  
  # Predicate satisfied:
  # e0 → e1
  
    ------------------------------------ [EvalIfTrue]
    If True Then False Else True → False
    -------------------------------------------------------------------------------------------- [EvalCtx]
    If ( If True Then False Else True ) Then False Else True → If ( False ) Then False Else True
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  False : bool                                                                                 
  ---------------- [Tbool]                                                                     
  {} ⊢ False, Bool                      False : bool                True : bool                T1 = Bool = T2
  ------------------------ [TParens]    ---------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]
  {} ⊢ ( False ), Bool                  {} ⊢ False, Bool            {} ⊢ True, Bool            Bool == Bool
  -------------------------------------------------------------------------------------------------------------- [TIf]
  {} ⊢ If ( False ) Then False Else True, Bool
  -------------------------------------------------------------------------------------------------------- [TEmptyCtx]
  If ( False ) Then False Else True :: Bool
  
  
Property successfull
# Property Preservation proven by failing predicate with assignment {e0 --> 42}:
  # Success: e0 :: T
  # Failed: e0 → e1
# e0 → e1 failed because: 
  While trying to proof that (→) is applicable to "42":
    Not a single rule matched:
    While trying to intepret the rule EvalCtx with 42:
      Evaluation contexts only searching within a parse tree and don't handle literals
    While trying to intepret the rule EvalPlus with 42:
      :
        FT: Could not pattern match '42' over 'n1 "+" n2'
    While trying to intepret the rule EvalAscrBool with 42:
      :
        FT: Could not pattern match '42' over 'b "::" "Bool"'
    While trying to intepret the rule EvalAscrInt with 42:
      :
        FT: Could not pattern match '42' over 'i "::" "Int"'
    While trying to intepret the rule EvalParens with 42:
      :
        FT: Could not pattern match '42' over '"(" e ")"'
    While trying to intepret the rule EvalIfTrue with 42:
      :
        FT: Could not pattern match '42' over '"If" "True" "Then" e1 "Else" e2'
    While trying to intepret the rule EvalIfFalse with 42:
      :
        FT: Could not pattern match '42' over '"If" "False" "Then" e1 "Else" e2'
    While trying to intepret the rule EvalLamApp with 42:
      :
        FT: Could not pattern match '42' over '("(" "\\" var ":" type "." e ")") arg'
Property successfull
# Property Preservation statisfied with assignment {T --> Int, e0 --> 1 + 2, e1 --> 3}
  # Predicate satisfied:
  # e0 :: T
  
    1 : number               2 : number
    ----------- [Tnumber]    ----------- [Tnumber]
    {} ⊢ 1, Int              {} ⊢ 2, Int
    -------------------------------------- [TPlus]
    {} ⊢ 1 + 2, Int
    ---------------------------------- [TEmptyCtx]
    1 + 2 :: Int
  
  # Predicate satisfied:
  # e0 → e1
  
    1 : Number    2 : Number
    ------------------------ [EvalPlus]
    1 + 2 → 3
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  3 : number
  ----------- [Tnumber]
  {} ⊢ 3, Int
  --------------------- [TEmptyCtx]
  3 :: Int
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Int, e0 --> ( \ f : Int -> Int . f 5 ) ( \ i : Int . i + 1 ), e1 --> ( \ i : Int . i + 1 ) 5}
  # Predicate satisfied:
  # e0 :: T
  
                                                5 : number                                T1 = Int = T2                                           1 : number                         
    ----------------------------------- [Tx]    ---------------------------- [Tnumber]    ------------- [EqBase]    --------------------- [Tx]    --------------------- [Tnumber]    
    f : Int -> Int , {} ⊢ f, Int -> Int         f : Int -> Int , {} ⊢ 5, Int              Int == Int                i : Int , {} ⊢ i, Int         i : Int , {} ⊢ 1, Int              
    ----------------------------------------------------------------------------------------------------- [Tapp]    ----------------------------------------------------- [TPlus]    
    f : Int -> Int , {} ⊢ f 5, Int                                                                                  i : Int , {} ⊢ i + 1, Int                                        T1 = Int -> Int = T2
    -------------------------------------------------------------------------------------------------- [TLambda]    --------------------------------------------------- [TLambda]    ------------------------ [EqBase]
    {} ⊢ ( \ f : Int -> Int . f 5 ), Int -> Int -> Int                                                              {} ⊢ ( \ i : Int . i + 1 ), Int -> Int                           Int -> Int == Int -> Int
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [Tapp]
    {} ⊢ ( \ f : Int -> Int . f 5 ) ( \ i : Int . i + 1 ), Int
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ [TEmptyCtx]
    ( \ f : Int -> Int . f 5 ) ( \ i : Int . i + 1 ) :: Int
  
  # Predicate satisfied:
  # e0 → e1
  
    -------------------------------------------------------------------------- [EvalLamApp]
    ( \ f : Int -> Int . f 5 ) ( \ i : Int . i + 1 ) → ( \ i : Int . i + 1 ) 5
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
                                1 : number                                                  
  --------------------- [Tx]    --------------------- [Tnumber]                             
  i : Int , {} ⊢ i, Int         i : Int , {} ⊢ 1, Int                                       
  ----------------------------------------------------- [TPlus]                             
  i : Int , {} ⊢ i + 1, Int                                        5 : number               T1 = Int = T2
  --------------------------------------------------- [TLambda]    ----------- [Tnumber]    ------------- [EqBase]
  {} ⊢ ( \ i : Int . i + 1 ), Int -> Int                           {} ⊢ 5, Int              Int == Int
  --------------------------------------------------------------------------------------------------------- [Tapp]
  {} ⊢ ( \ i : Int . i + 1 ) 5, Int
  ---------------------------------------------------------------------------------------------------- [TEmptyCtx]
  ( \ i : Int . i + 1 ) 5 :: Int
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Bool, e0 --> ( True ), e1 --> True}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool
    --------------- [Tbool]
    {} ⊢ True, Bool
    ----------------------- [TParens]
    {} ⊢ ( True ), Bool
    --------------------------------- [TEmptyCtx]
    ( True ) :: Bool
  
  # Predicate satisfied:
  # e0 → e1
  
    --------------- [EvalParens]
    ( True ) → True
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  True : bool
  --------------- [Tbool]
  {} ⊢ True, Bool
  ----------------------- [TEmptyCtx]
  True :: Bool
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Bool, e0 --> False :: Bool, e1 --> False}
  # Predicate satisfied:
  # e0 :: T
  
    False : bool                T1 = Bool = T2
    ---------------- [Tbool]    -------------- [EqBase]
    {} ⊢ False, Bool            Bool == Bool
    ------------------------------------------- [TAscr]
    {} ⊢ False :: Bool, Bool
    --------------------------------------- [TEmptyCtx]
    False :: Bool :: Bool
  
  # Predicate satisfied:
  # e0 → e1
  
    False : bool
    --------------------- [EvalAscrBool]
    False :: Bool → False
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  False : bool
  ---------------- [Tbool]
  {} ⊢ False, Bool
  ------------------------ [TEmptyCtx]
  False :: Bool
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Bool, e0 --> ( True ), e1 --> True}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool
    --------------- [Tbool]
    {} ⊢ True, Bool
    ----------------------- [TParens]
    {} ⊢ ( True ), Bool
    --------------------------------- [TEmptyCtx]
    ( True ) :: Bool
  
  # Predicate satisfied:
  # e0 → e1
  
    --------------- [EvalParens]
    ( True ) → True
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  True : bool
  --------------- [Tbool]
  {} ⊢ True, Bool
  ----------------------- [TEmptyCtx]
  True :: Bool
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Bool, e0 --> ( If True Then True Else True ) :: Bool, e1 --> ( True ) :: Bool}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool                True : bool                True : bool                T1 = Bool = T2             
    --------------- [Tbool]    --------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]    
    {} ⊢ True, Bool            {} ⊢ True, Bool            {} ⊢ True, Bool            Bool == Bool               
    -------------------------------------------------------------------------------------------------- [TIf]    
    {} ⊢ If True Then True Else True, Bool                                                                      T1 = Bool = T2
    ---------------------------------------------------------------------------------------------- [TParens]    -------------- [EqBase]
    {} ⊢ ( If True Then True Else True ), Bool                                                                  Bool == Bool
    --------------------------------------------------------------------------------------------------------------------------- [TAscr]
    {} ⊢ ( If True Then True Else True ) :: Bool, Bool
    ----------------------------------------------------------------------------------------------------------------------- [TEmptyCtx]
    ( If True Then True Else True ) :: Bool :: Bool
  
  # Predicate satisfied:
  # e0 → e1
  
    ---------------------------------- [EvalIfTrue]
    If True Then True Else True → True
    ---------------------------------------------------------- [EvalCtx]
    ( If True Then True Else True ) :: Bool → ( True ) :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  True : bool                          
  --------------- [Tbool]              
  {} ⊢ True, Bool                      T1 = Bool = T2
  ----------------------- [TParens]    -------------- [EqBase]
  {} ⊢ ( True ), Bool                  Bool == Bool
  ---------------------------------------------------- [TAscr]
  {} ⊢ ( True ) :: Bool, Bool
  ------------------------------------------------ [TEmptyCtx]
  ( True ) :: Bool :: Bool
  
  
Property successfull
# Property Preservation proven by failing predicate with assignment {e0 --> True}:
  # Success: e0 :: T
  # Failed: e0 → e1
# e0 → e1 failed because: 
  While trying to proof that (→) is applicable to "True":
    Not a single rule matched:
    While trying to intepret the rule EvalCtx with True:
      Evaluation contexts only searching within a parse tree and don't handle literals
    While trying to intepret the rule EvalPlus with True:
      :
        FT: Could not pattern match '"True"' over 'n1 "+" n2'
    While trying to intepret the rule EvalAscrBool with True:
      :
        FT: Could not pattern match '"True"' over 'b "::" "Bool"'
    While trying to intepret the rule EvalAscrInt with True:
      :
        FT: Could not pattern match '"True"' over 'i "::" "Int"'
    While trying to intepret the rule EvalParens with True:
      :
        FT: Could not pattern match '"True"' over '"(" e ")"'
    While trying to intepret the rule EvalIfTrue with True:
      :
        FT: Could not pattern match '"True"' over '"If" "True" "Then" e1 "Else" e2'
    While trying to intepret the rule EvalIfFalse with True:
      :
        FT: Could not pattern match '"True"' over '"If" "False" "Then" e1 "Else" e2'
    While trying to intepret the rule EvalLamApp with True:
      :
        FT: Could not pattern match '"True"' over '("(" "\\" var ":" type "." e ")") arg'
Property successfull
# Property Preservation statisfied with assignment {T --> Bool, e0 --> ( False ), e1 --> False}
  # Predicate satisfied:
  # e0 :: T
  
    False : bool
    ---------------- [Tbool]
    {} ⊢ False, Bool
    ------------------------ [TParens]
    {} ⊢ ( False ), Bool
    ---------------------------------- [TEmptyCtx]
    ( False ) :: Bool
  
  # Predicate satisfied:
  # e0 → e1
  
    ----------------- [EvalParens]
    ( False ) → False
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  False : bool
  ---------------- [Tbool]
  {} ⊢ False, Bool
  ------------------------ [TEmptyCtx]
  False :: Bool
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Bool, e0 --> True :: Bool, e1 --> True}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool                T1 = Bool = T2
    --------------- [Tbool]    -------------- [EqBase]
    {} ⊢ True, Bool            Bool == Bool
    ------------------------------------------ [TAscr]
    {} ⊢ True :: Bool, Bool
    -------------------------------------- [TEmptyCtx]
    True :: Bool :: Bool
  
  # Predicate satisfied:
  # e0 → e1
  
    True : bool
    ------------------- [EvalAscrBool]
    True :: Bool → True
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  True : bool
  --------------- [Tbool]
  {} ⊢ True, Bool
  ----------------------- [TEmptyCtx]
  True :: Bool
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Int, e0 --> If True Then 42 Else 43, e1 --> 42}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool                42 : number               43 : number               T1 = Int = T2
    --------------- [Tbool]    ------------ [Tnumber]    ------------ [Tnumber]    ------------- [EqBase]
    {} ⊢ True, Bool            {} ⊢ 42, Int              {} ⊢ 43, Int              Int == Int
    ----------------------------------------------------------------------------------------------- [TIf]
    {} ⊢ If True Then 42 Else 43, Int
    ----------------------------------------------------------------------------------------- [TEmptyCtx]
    If True Then 42 Else 43 :: Int
  
  # Predicate satisfied:
  # e0 → e1
  
    ---------------------------- [EvalIfTrue]
    If True Then 42 Else 43 → 42
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  42 : number
  ------------ [Tnumber]
  {} ⊢ 42, Int
  ---------------------- [TEmptyCtx]
  42 :: Int
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Int, e0 --> If False Then 23 Else 44, e1 --> 44}
  # Predicate satisfied:
  # e0 :: T
  
    False : bool                23 : number               44 : number               T1 = Int = T2
    ---------------- [Tbool]    ------------ [Tnumber]    ------------ [Tnumber]    ------------- [EqBase]
    {} ⊢ False, Bool            {} ⊢ 23, Int              {} ⊢ 44, Int              Int == Int
    ------------------------------------------------------------------------------------------------ [TIf]
    {} ⊢ If False Then 23 Else 44, Int
    ------------------------------------------------------------------------------------------ [TEmptyCtx]
    If False Then 23 Else 44 :: Int
  
  # Predicate satisfied:
  # e0 → e1
  
    ----------------------------- [EvalIfFalse]
    If False Then 23 Else 44 → 44
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  44 : number
  ------------ [Tnumber]
  {} ⊢ 44, Int
  ---------------------- [TEmptyCtx]
  44 :: Int
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Int, e0 --> 5 + 6, e1 --> 11}
  # Predicate satisfied:
  # e0 :: T
  
    5 : number               6 : number
    ----------- [Tnumber]    ----------- [Tnumber]
    {} ⊢ 5, Int              {} ⊢ 6, Int
    -------------------------------------- [TPlus]
    {} ⊢ 5 + 6, Int
    ---------------------------------- [TEmptyCtx]
    5 + 6 :: Int
  
  # Predicate satisfied:
  # e0 → e1
  
    5 : Number    6 : Number
    ------------------------ [EvalPlus]
    5 + 6 → 11
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  11 : number
  ------------ [Tnumber]
  {} ⊢ 11, Int
  ---------------------- [TEmptyCtx]
  11 :: Int
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Int, e0 --> 5 + 6 + 7, e1 --> 5 + 13}
  # Predicate satisfied:
  # e0 :: T
  
                             6 : number               7 : number
                             ----------- [Tnumber]    ----------- [Tnumber]
    5 : number               {} ⊢ 6, Int              {} ⊢ 7, Int
    ----------- [Tnumber]    -------------------------------------- [TPlus]
    {} ⊢ 5, Int              {} ⊢ 6 + 7, Int
    --------------------------------------------------------------- [TPlus]
    {} ⊢ 5 + 6 + 7, Int
    ----------------------------------------------------------- [TEmptyCtx]
    5 + 6 + 7 :: Int
  
  # Predicate satisfied:
  # e0 → e1
  
    6 : Number    7 : Number
    ------------------------ [EvalPlus]
    6 + 7 → 13
    ------------------------- [EvalCtx]
    5 + 6 + 7 → 5 + 13
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  5 : number               13 : number
  ----------- [Tnumber]    ------------ [Tnumber]
  {} ⊢ 5, Int              {} ⊢ 13, Int
  --------------------------------------- [TPlus]
  {} ⊢ 5 + 13, Int
  ----------------------------------- [TEmptyCtx]
  5 + 13 :: Int
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Int, e0 --> ( \ x : Int . x + 1 ) 5, e1 --> 5 + 1}
  # Predicate satisfied:
  # e0 :: T
  
                                  1 : number                                                  
    --------------------- [Tx]    --------------------- [Tnumber]                             
    x : Int , {} ⊢ x, Int         x : Int , {} ⊢ 1, Int                                       
    ----------------------------------------------------- [TPlus]                             
    x : Int , {} ⊢ x + 1, Int                                        5 : number               T1 = Int = T2
    --------------------------------------------------- [TLambda]    ----------- [Tnumber]    ------------- [EqBase]
    {} ⊢ ( \ x : Int . x + 1 ), Int -> Int                           {} ⊢ 5, Int              Int == Int
    --------------------------------------------------------------------------------------------------------- [Tapp]
    {} ⊢ ( \ x : Int . x + 1 ) 5, Int
    ---------------------------------------------------------------------------------------------------- [TEmptyCtx]
    ( \ x : Int . x + 1 ) 5 :: Int
  
  # Predicate satisfied:
  # e0 → e1
  
    ------------------------------- [EvalLamApp]
    ( \ x : Int . x + 1 ) 5 → 5 + 1
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  5 : number               1 : number
  ----------- [Tnumber]    ----------- [Tnumber]
  {} ⊢ 5, Int              {} ⊢ 1, Int
  -------------------------------------- [TPlus]
  {} ⊢ 5 + 1, Int
  ---------------------------------- [TEmptyCtx]
  5 + 1 :: Int
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Int, e0 --> If ( If True Then False Else True ) Then 123456 Else 42, e1 --> If ( False ) Then 123456 Else 42}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool                False : bool                True : bool                T1 = Bool = T2                                                                     
    --------------- [Tbool]    ---------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]                                                            
    {} ⊢ True, Bool            {} ⊢ False, Bool            {} ⊢ True, Bool            Bool == Bool                                                                       
    --------------------------------------------------------------------------------------------------- [TIf]                                                            
    {} ⊢ If True Then False Else True, Bool                                                                      123456 : number               42 : number               T1 = Int = T2
    ----------------------------------------------------------------------------------------------- [TParens]    ---------------- [Tnumber]    ------------ [Tnumber]    ------------- [EqBase]
    {} ⊢ ( If True Then False Else True ), Bool                                                                  {} ⊢ 123456, Int              {} ⊢ 42, Int              Int == Int
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [TIf]
    {} ⊢ If ( If True Then False Else True ) Then 123456 Else 42, Int
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [TEmptyCtx]
    If ( If True Then False Else True ) Then 123456 Else 42 :: Int
  
  # Predicate satisfied:
  # e0 → e1
  
    ------------------------------------ [EvalIfTrue]
    If True Then False Else True → False
    ------------------------------------------------------------------------------------------ [EvalCtx]
    If ( If True Then False Else True ) Then 123456 Else 42 → If ( False ) Then 123456 Else 42
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
  False : bool                                                                                  
  ---------------- [Tbool]                                                                      
  {} ⊢ False, Bool                      123456 : number               42 : number               T1 = Int = T2
  ------------------------ [TParens]    ---------------- [Tnumber]    ------------ [Tnumber]    ------------- [EqBase]
  {} ⊢ ( False ), Bool                  {} ⊢ 123456, Int              {} ⊢ 42, Int              Int == Int
  -------------------------------------------------------------------------------------------------------------- [TIf]
  {} ⊢ If ( False ) Then 123456 Else 42, Int
  -------------------------------------------------------------------------------------------------------- [TEmptyCtx]
  If ( False ) Then 123456 Else 42 :: Int
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Int, e0 --> 5 + ( 6 + 7 ), e1 --> 5 + ( 13 )}
  # Predicate satisfied:
  # e0 :: T
  
                             6 : number               7 : number
                             ----------- [Tnumber]    ----------- [Tnumber]
                             {} ⊢ 6, Int              {} ⊢ 7, Int
                             -------------------------------------- [TPlus]
    5 : number               {} ⊢ 6 + 7, Int
    ----------- [Tnumber]    ------------------------------------ [TParens]
    {} ⊢ 5, Int              {} ⊢ ( 6 + 7 ), Int
    --------------------------------------------------------------- [TPlus]
    {} ⊢ 5 + ( 6 + 7 ), Int
    ----------------------------------------------------------- [TEmptyCtx]
    5 + ( 6 + 7 ) :: Int
  
  # Predicate satisfied:
  # e0 → e1
  
    6 : Number    7 : Number
    ------------------------ [EvalPlus]
    6 + 7 → 13
    ------------------------- [EvalCtx]
    5 + ( 6 + 7 ) → 5 + ( 13 )
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
                           13 : number
                           ------------ [Tnumber]
  5 : number               {} ⊢ 13, Int
  ----------- [Tnumber]    ---------------------- [TParens]
  {} ⊢ 5, Int              {} ⊢ ( 13 ), Int
  ------------------------------------------------- [TPlus]
  {} ⊢ 5 + ( 13 ), Int
  --------------------------------------------- [TEmptyCtx]
  5 + ( 13 ) :: Int
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Int, e0 --> ( 5 + 6 ) + ( 7 + 8 ), e1 --> ( 11 ) + ( 7 + 8 )}
  # Predicate satisfied:
  # e0 :: T
  
    5 : number               6 : number               7 : number               8 : number
    ----------- [Tnumber]    ----------- [Tnumber]    ----------- [Tnumber]    ----------- [Tnumber]
    {} ⊢ 5, Int              {} ⊢ 6, Int              {} ⊢ 7, Int              {} ⊢ 8, Int
    -------------------------------------- [TPlus]    -------------------------------------- [TPlus]
    {} ⊢ 5 + 6, Int                                   {} ⊢ 7 + 8, Int
    ------------------------------------ [TParens]    ------------------------------------ [TParens]
    {} ⊢ ( 5 + 6 ), Int                               {} ⊢ ( 7 + 8 ), Int
    ---------------------------------------------------------------------------------------- [TPlus]
    {} ⊢ ( 5 + 6 ) + ( 7 + 8 ), Int
    ------------------------------------------------------------------------------------ [TEmptyCtx]
    ( 5 + 6 ) + ( 7 + 8 ) :: Int
  
  # Predicate satisfied:
  # e0 → e1
  
    5 : Number    6 : Number
    ------------------------ [EvalPlus]
    5 + 6 → 11
    ------------------------------------------ [EvalCtx]
    ( 5 + 6 ) + ( 7 + 8 ) → ( 11 ) + ( 7 + 8 )
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
                                      7 : number               8 : number
                                      ----------- [Tnumber]    ----------- [Tnumber]
  11 : number                         {} ⊢ 7, Int              {} ⊢ 8, Int
  ------------ [Tnumber]              -------------------------------------- [TPlus]
  {} ⊢ 11, Int                        {} ⊢ 7 + 8, Int
  ---------------------- [TParens]    ------------------------------------ [TParens]
  {} ⊢ ( 11 ), Int                    {} ⊢ ( 7 + 8 ), Int
  -------------------------------------------------------------------------- [TPlus]
  {} ⊢ ( 11 ) + ( 7 + 8 ), Int
  ---------------------------------------------------------------------- [TEmptyCtx]
  ( 11 ) + ( 7 + 8 ) :: Int
  
  
Property successfull
# Property Preservation statisfied with assignment {T --> Int, e0 --> 5 + ( 6 + ( 7 + 8 ) ), e1 --> 5 + ( 6 + ( 15 ) )}
  # Predicate satisfied:
  # e0 :: T
  
                                                      7 : number               8 : number
                                                      ----------- [Tnumber]    ----------- [Tnumber]
                                                      {} ⊢ 7, Int              {} ⊢ 8, Int
                                                      -------------------------------------- [TPlus]
                             6 : number               {} ⊢ 7 + 8, Int
                             ----------- [Tnumber]    ------------------------------------ [TParens]
                             {} ⊢ 6, Int              {} ⊢ ( 7 + 8 ), Int
                             --------------------------------------------------------------- [TPlus]
    5 : number               {} ⊢ 6 + ( 7 + 8 ), Int
    ----------- [Tnumber]    ------------------------------------------------------------- [TParens]
    {} ⊢ 5, Int              {} ⊢ ( 6 + ( 7 + 8 ) ), Int
    ---------------------------------------------------------------------------------------- [TPlus]
    {} ⊢ 5 + ( 6 + ( 7 + 8 ) ), Int
    ------------------------------------------------------------------------------------ [TEmptyCtx]
    5 + ( 6 + ( 7 + 8 ) ) :: Int
  
  # Predicate satisfied:
  # e0 → e1
  
    7 : Number    8 : Number
    ------------------------ [EvalPlus]
    7 + 8 → 15
    ------------------------------------------ [EvalCtx]
    5 + ( 6 + ( 7 + 8 ) ) → 5 + ( 6 + ( 15 ) )
  
  
  
  # Satisfies a possible conclusion:
  # e1 :: T
  
                                                    15 : number
                                                    ------------ [Tnumber]
                           6 : number               {} ⊢ 15, Int
                           ----------- [Tnumber]    ---------------------- [TParens]
                           {} ⊢ 6, Int              {} ⊢ ( 15 ), Int
                           ------------------------------------------------- [TPlus]
  5 : number               {} ⊢ 6 + ( 15 ), Int
  ----------- [Tnumber]    ----------------------------------------------- [TParens]
  {} ⊢ 5, Int              {} ⊢ ( 6 + ( 15 ) ), Int
  -------------------------------------------------------------------------- [TPlus]
  {} ⊢ 5 + ( 6 + ( 15 ) ), Int
  ---------------------------------------------------------------------- [TEmptyCtx]
  5 + ( 6 + ( 15 ) ) :: Int
  
  
Property successfull
# Property Preservation proven by failing predicate with assignment {e0 --> ( \ x : Int . x + 1 ) True}:
  # Failed: e0 :: T
  # Failed: e0 → e1
# e0 :: T failed because: 
  While trying to proof that (::) is applicable to "( \ x : Int . x + 1 ) True":
    Not a single rule matched:
    While trying to intepret the rule TEmptyCtx with ( \ x : Int . x + 1 ) True:
      While trying to proof that (⊢) is applicable to "{}, ( \ x : Int . x + 1 ) True":
        Not a single rule matched:
        While trying to intepret the rule Tnumber with {}, ( \ x : Int . x + 1 ) True:
          n = ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True" is not a "number" but a "e"
        While trying to intepret the rule Tbool with {}, ( \ x : Int . x + 1 ) True:
          b = ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True" is not a "bool" but a "e"
        While trying to intepret the rule TParens with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: "(" e ")" /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule TAscr with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: e "::" T /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule Tx with {}, ( \ x : Int . x + 1 ) True:
          Evaluation contexts only searching within a parse tree and don't handle literals
        While trying to intepret the rule TPlus with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: n1 "+" n2 /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule TIf with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: "If" c "Then" e1 "Else" e2 /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule TLambda with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: "(" "\\" x ":" T1 "." e ")" /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule Tapp with {}, ( \ x : Int . x + 1 ) True:
          While trying to proof that (==) is applicable to "Bool, Int":
            Not a single rule matched:
            While trying to intepret the rule EqBase with Bool, Int:
              Equality predicate not met: T1="Bool" /= "Int"=T2
            While trying to intepret the rule EqArrow with Bool, Int:
              :
                FT: Could not pattern match '"Bool"' over 'Ta1 "->" Tb1'
# e0 → e1 failed because: 
  Proof not attempted as previous predicate failed
Property Progress holds for given examples                                      
Property successfull
# Property Progress statisfied with assignment {T --> Bool, e0 --> True}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool
    --------------- [Tbool]
    {} ⊢ True, Bool
    ----------------------- [TEmptyCtx]
    True :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # (✓) e0
  
  True : bool
  ----------- [CanonBool]
  (✓) True
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Bool, e0 --> False}
  # Predicate satisfied:
  # e0 :: T
  
    False : bool
    ---------------- [Tbool]
    {} ⊢ False, Bool
    ------------------------ [TEmptyCtx]
    False :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # (✓) e0
  
  False : bool
  ------------ [CanonBool]
  (✓) False
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Bool, e0 --> If True Then False Else True}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool                False : bool                True : bool                T1 = Bool = T2
    --------------- [Tbool]    ---------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]
    {} ⊢ True, Bool            {} ⊢ False, Bool            {} ⊢ True, Bool            Bool == Bool
    --------------------------------------------------------------------------------------------------- [TIf]
    {} ⊢ If True Then False Else True, Bool
    --------------------------------------------------------------------------------------------- [TEmptyCtx]
    If True Then False Else True :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  ------------------------------------ [EvalIfTrue]
  If True Then False Else True → False
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Bool, e0 --> If ( If True Then False Else True ) Then False Else True}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool                False : bool                True : bool                T1 = Bool = T2                                                                    
    --------------- [Tbool]    ---------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]                                                           
    {} ⊢ True, Bool            {} ⊢ False, Bool            {} ⊢ True, Bool            Bool == Bool                                                                      
    --------------------------------------------------------------------------------------------------- [TIf]                                                           
    {} ⊢ If True Then False Else True, Bool                                                                      False : bool                True : bool                T1 = Bool = T2
    ----------------------------------------------------------------------------------------------- [TParens]    ---------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]
    {} ⊢ ( If True Then False Else True ), Bool                                                                  {} ⊢ False, Bool            {} ⊢ True, Bool            Bool == Bool
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [TIf]
    {} ⊢ If ( If True Then False Else True ) Then False Else True, Bool
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [TEmptyCtx]
    If ( If True Then False Else True ) Then False Else True :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  ------------------------------------ [EvalIfTrue]
  If True Then False Else True → False
  -------------------------------------------------------------------------------------------- [EvalCtx]
  If ( If True Then False Else True ) Then False Else True → If ( False ) Then False Else True
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Int, e0 --> 42}
  # Predicate satisfied:
  # e0 :: T
  
    42 : number
    ------------ [Tnumber]
    {} ⊢ 42, Int
    ---------------------- [TEmptyCtx]
    42 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # (✓) e0
  
  42 : number
  ----------- [CanonNumber]
  (✓) 42
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Int, e0 --> 1 + 2}
  # Predicate satisfied:
  # e0 :: T
  
    1 : number               2 : number
    ----------- [Tnumber]    ----------- [Tnumber]
    {} ⊢ 1, Int              {} ⊢ 2, Int
    -------------------------------------- [TPlus]
    {} ⊢ 1 + 2, Int
    ---------------------------------- [TEmptyCtx]
    1 + 2 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  1 : Number    2 : Number
  ------------------------ [EvalPlus]
  1 + 2 → 3
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Int, e0 --> ( \ f : Int -> Int . f 5 ) ( \ i : Int . i + 1 )}
  # Predicate satisfied:
  # e0 :: T
  
                                                5 : number                                T1 = Int = T2                                           1 : number                         
    ----------------------------------- [Tx]    ---------------------------- [Tnumber]    ------------- [EqBase]    --------------------- [Tx]    --------------------- [Tnumber]    
    f : Int -> Int , {} ⊢ f, Int -> Int         f : Int -> Int , {} ⊢ 5, Int              Int == Int                i : Int , {} ⊢ i, Int         i : Int , {} ⊢ 1, Int              
    ----------------------------------------------------------------------------------------------------- [Tapp]    ----------------------------------------------------- [TPlus]    
    f : Int -> Int , {} ⊢ f 5, Int                                                                                  i : Int , {} ⊢ i + 1, Int                                        T1 = Int -> Int = T2
    -------------------------------------------------------------------------------------------------- [TLambda]    --------------------------------------------------- [TLambda]    ------------------------ [EqBase]
    {} ⊢ ( \ f : Int -> Int . f 5 ), Int -> Int -> Int                                                              {} ⊢ ( \ i : Int . i + 1 ), Int -> Int                           Int -> Int == Int -> Int
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [Tapp]
    {} ⊢ ( \ f : Int -> Int . f 5 ) ( \ i : Int . i + 1 ), Int
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ [TEmptyCtx]
    ( \ f : Int -> Int . f 5 ) ( \ i : Int . i + 1 ) :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  -------------------------------------------------------------------------- [EvalLamApp]
  ( \ f : Int -> Int . f 5 ) ( \ i : Int . i + 1 ) → ( \ i : Int . i + 1 ) 5
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Bool, e0 --> ( True )}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool
    --------------- [Tbool]
    {} ⊢ True, Bool
    ----------------------- [TParens]
    {} ⊢ ( True ), Bool
    --------------------------------- [TEmptyCtx]
    ( True ) :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  --------------- [EvalParens]
  ( True ) → True
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Bool, e0 --> False :: Bool}
  # Predicate satisfied:
  # e0 :: T
  
    False : bool                T1 = Bool = T2
    ---------------- [Tbool]    -------------- [EqBase]
    {} ⊢ False, Bool            Bool == Bool
    ------------------------------------------- [TAscr]
    {} ⊢ False :: Bool, Bool
    --------------------------------------- [TEmptyCtx]
    False :: Bool :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  False : bool
  --------------------- [EvalAscrBool]
  False :: Bool → False
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Bool, e0 --> ( True )}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool
    --------------- [Tbool]
    {} ⊢ True, Bool
    ----------------------- [TParens]
    {} ⊢ ( True ), Bool
    --------------------------------- [TEmptyCtx]
    ( True ) :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  --------------- [EvalParens]
  ( True ) → True
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Bool, e0 --> ( If True Then True Else True ) :: Bool}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool                True : bool                True : bool                T1 = Bool = T2             
    --------------- [Tbool]    --------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]    
    {} ⊢ True, Bool            {} ⊢ True, Bool            {} ⊢ True, Bool            Bool == Bool               
    -------------------------------------------------------------------------------------------------- [TIf]    
    {} ⊢ If True Then True Else True, Bool                                                                      T1 = Bool = T2
    ---------------------------------------------------------------------------------------------- [TParens]    -------------- [EqBase]
    {} ⊢ ( If True Then True Else True ), Bool                                                                  Bool == Bool
    --------------------------------------------------------------------------------------------------------------------------- [TAscr]
    {} ⊢ ( If True Then True Else True ) :: Bool, Bool
    ----------------------------------------------------------------------------------------------------------------------- [TEmptyCtx]
    ( If True Then True Else True ) :: Bool :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  ---------------------------------- [EvalIfTrue]
  If True Then True Else True → True
  ---------------------------------------------------------- [EvalCtx]
  ( If True Then True Else True ) :: Bool → ( True ) :: Bool
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Bool, e0 --> True}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool
    --------------- [Tbool]
    {} ⊢ True, Bool
    ----------------------- [TEmptyCtx]
    True :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # (✓) e0
  
  True : bool
  ----------- [CanonBool]
  (✓) True
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Bool, e0 --> ( False )}
  # Predicate satisfied:
  # e0 :: T
  
    False : bool
    ---------------- [Tbool]
    {} ⊢ False, Bool
    ------------------------ [TParens]
    {} ⊢ ( False ), Bool
    ---------------------------------- [TEmptyCtx]
    ( False ) :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  ----------------- [EvalParens]
  ( False ) → False
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Bool, e0 --> True :: Bool}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool                T1 = Bool = T2
    --------------- [Tbool]    -------------- [EqBase]
    {} ⊢ True, Bool            Bool == Bool
    ------------------------------------------ [TAscr]
    {} ⊢ True :: Bool, Bool
    -------------------------------------- [TEmptyCtx]
    True :: Bool :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  True : bool
  ------------------- [EvalAscrBool]
  True :: Bool → True
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Int, e0 --> If True Then 42 Else 43}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool                42 : number               43 : number               T1 = Int = T2
    --------------- [Tbool]    ------------ [Tnumber]    ------------ [Tnumber]    ------------- [EqBase]
    {} ⊢ True, Bool            {} ⊢ 42, Int              {} ⊢ 43, Int              Int == Int
    ----------------------------------------------------------------------------------------------- [TIf]
    {} ⊢ If True Then 42 Else 43, Int
    ----------------------------------------------------------------------------------------- [TEmptyCtx]
    If True Then 42 Else 43 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  ---------------------------- [EvalIfTrue]
  If True Then 42 Else 43 → 42
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Int, e0 --> If False Then 23 Else 44}
  # Predicate satisfied:
  # e0 :: T
  
    False : bool                23 : number               44 : number               T1 = Int = T2
    ---------------- [Tbool]    ------------ [Tnumber]    ------------ [Tnumber]    ------------- [EqBase]
    {} ⊢ False, Bool            {} ⊢ 23, Int              {} ⊢ 44, Int              Int == Int
    ------------------------------------------------------------------------------------------------ [TIf]
    {} ⊢ If False Then 23 Else 44, Int
    ------------------------------------------------------------------------------------------ [TEmptyCtx]
    If False Then 23 Else 44 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  ----------------------------- [EvalIfFalse]
  If False Then 23 Else 44 → 44
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Int, e0 --> 5 + 6}
  # Predicate satisfied:
  # e0 :: T
  
    5 : number               6 : number
    ----------- [Tnumber]    ----------- [Tnumber]
    {} ⊢ 5, Int              {} ⊢ 6, Int
    -------------------------------------- [TPlus]
    {} ⊢ 5 + 6, Int
    ---------------------------------- [TEmptyCtx]
    5 + 6 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  5 : Number    6 : Number
  ------------------------ [EvalPlus]
  5 + 6 → 11
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Int, e0 --> 5 + 6 + 7}
  # Predicate satisfied:
  # e0 :: T
  
                             6 : number               7 : number
                             ----------- [Tnumber]    ----------- [Tnumber]
    5 : number               {} ⊢ 6, Int              {} ⊢ 7, Int
    ----------- [Tnumber]    -------------------------------------- [TPlus]
    {} ⊢ 5, Int              {} ⊢ 6 + 7, Int
    --------------------------------------------------------------- [TPlus]
    {} ⊢ 5 + 6 + 7, Int
    ----------------------------------------------------------- [TEmptyCtx]
    5 + 6 + 7 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  6 : Number    7 : Number
  ------------------------ [EvalPlus]
  6 + 7 → 13
  ------------------------- [EvalCtx]
  5 + 6 + 7 → 5 + 13
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Int, e0 --> ( \ x : Int . x + 1 ) 5}
  # Predicate satisfied:
  # e0 :: T
  
                                  1 : number                                                  
    --------------------- [Tx]    --------------------- [Tnumber]                             
    x : Int , {} ⊢ x, Int         x : Int , {} ⊢ 1, Int                                       
    ----------------------------------------------------- [TPlus]                             
    x : Int , {} ⊢ x + 1, Int                                        5 : number               T1 = Int = T2
    --------------------------------------------------- [TLambda]    ----------- [Tnumber]    ------------- [EqBase]
    {} ⊢ ( \ x : Int . x + 1 ), Int -> Int                           {} ⊢ 5, Int              Int == Int
    --------------------------------------------------------------------------------------------------------- [Tapp]
    {} ⊢ ( \ x : Int . x + 1 ) 5, Int
    ---------------------------------------------------------------------------------------------------- [TEmptyCtx]
    ( \ x : Int . x + 1 ) 5 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  ------------------------------- [EvalLamApp]
  ( \ x : Int . x + 1 ) 5 → 5 + 1
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Int, e0 --> If ( If True Then False Else True ) Then 123456 Else 42}
  # Predicate satisfied:
  # e0 :: T
  
    True : bool                False : bool                True : bool                T1 = Bool = T2                                                                     
    --------------- [Tbool]    ---------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]                                                            
    {} ⊢ True, Bool            {} ⊢ False, Bool            {} ⊢ True, Bool            Bool == Bool                                                                       
    --------------------------------------------------------------------------------------------------- [TIf]                                                            
    {} ⊢ If True Then False Else True, Bool                                                                      123456 : number               42 : number               T1 = Int = T2
    ----------------------------------------------------------------------------------------------- [TParens]    ---------------- [Tnumber]    ------------ [Tnumber]    ------------- [EqBase]
    {} ⊢ ( If True Then False Else True ), Bool                                                                  {} ⊢ 123456, Int              {} ⊢ 42, Int              Int == Int
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [TIf]
    {} ⊢ If ( If True Then False Else True ) Then 123456 Else 42, Int
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [TEmptyCtx]
    If ( If True Then False Else True ) Then 123456 Else 42 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  ------------------------------------ [EvalIfTrue]
  If True Then False Else True → False
  ------------------------------------------------------------------------------------------ [EvalCtx]
  If ( If True Then False Else True ) Then 123456 Else 42 → If ( False ) Then 123456 Else 42
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Int, e0 --> 5 + ( 6 + 7 )}
  # Predicate satisfied:
  # e0 :: T
  
                             6 : number               7 : number
                             ----------- [Tnumber]    ----------- [Tnumber]
                             {} ⊢ 6, Int              {} ⊢ 7, Int
                             -------------------------------------- [TPlus]
    5 : number               {} ⊢ 6 + 7, Int
    ----------- [Tnumber]    ------------------------------------ [TParens]
    {} ⊢ 5, Int              {} ⊢ ( 6 + 7 ), Int
    --------------------------------------------------------------- [TPlus]
    {} ⊢ 5 + ( 6 + 7 ), Int
    ----------------------------------------------------------- [TEmptyCtx]
    5 + ( 6 + 7 ) :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  6 : Number    7 : Number
  ------------------------ [EvalPlus]
  6 + 7 → 13
  ------------------------- [EvalCtx]
  5 + ( 6 + 7 ) → 5 + ( 13 )
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Int, e0 --> ( 5 + 6 ) + ( 7 + 8 )}
  # Predicate satisfied:
  # e0 :: T
  
    5 : number               6 : number               7 : number               8 : number
    ----------- [Tnumber]    ----------- [Tnumber]    ----------- [Tnumber]    ----------- [Tnumber]
    {} ⊢ 5, Int              {} ⊢ 6, Int              {} ⊢ 7, Int              {} ⊢ 8, Int
    -------------------------------------- [TPlus]    -------------------------------------- [TPlus]
    {} ⊢ 5 + 6, Int                                   {} ⊢ 7 + 8, Int
    ------------------------------------ [TParens]    ------------------------------------ [TParens]
    {} ⊢ ( 5 + 6 ), Int                               {} ⊢ ( 7 + 8 ), Int
    ---------------------------------------------------------------------------------------- [TPlus]
    {} ⊢ ( 5 + 6 ) + ( 7 + 8 ), Int
    ------------------------------------------------------------------------------------ [TEmptyCtx]
    ( 5 + 6 ) + ( 7 + 8 ) :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  5 : Number    6 : Number
  ------------------------ [EvalPlus]
  5 + 6 → 11
  ------------------------------------------ [EvalCtx]
  ( 5 + 6 ) + ( 7 + 8 ) → ( 11 ) + ( 7 + 8 )
  
  
Property successfull
# Property Progress statisfied with assignment {T --> Int, e0 --> 5 + ( 6 + ( 7 + 8 ) )}
  # Predicate satisfied:
  # e0 :: T
  
                                                      7 : number               8 : number
                                                      ----------- [Tnumber]    ----------- [Tnumber]
                                                      {} ⊢ 7, Int              {} ⊢ 8, Int
                                                      -------------------------------------- [TPlus]
                             6 : number               {} ⊢ 7 + 8, Int
                             ----------- [Tnumber]    ------------------------------------ [TParens]
                             {} ⊢ 6, Int              {} ⊢ ( 7 + 8 ), Int
                             --------------------------------------------------------------- [TPlus]
    5 : number               {} ⊢ 6 + ( 7 + 8 ), Int
    ----------- [Tnumber]    ------------------------------------------------------------- [TParens]
    {} ⊢ 5, Int              {} ⊢ ( 6 + ( 7 + 8 ) ), Int
    ---------------------------------------------------------------------------------------- [TPlus]
    {} ⊢ 5 + ( 6 + ( 7 + 8 ) ), Int
    ------------------------------------------------------------------------------------ [TEmptyCtx]
    5 + ( 6 + ( 7 + 8 ) ) :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e0 → e1
  
  7 : Number    8 : Number
  ------------------------ [EvalPlus]
  7 + 8 → 15
  ------------------------------------------ [EvalCtx]
  5 + ( 6 + ( 7 + 8 ) ) → 5 + ( 6 + ( 15 ) )
  
  
Property successfull
# Property Progress proven by failing predicate with assignment {e0 --> ( \ x : Int . x + 1 ) True}:
  # Failed: e0 :: T
# e0 :: T failed because: 
  While trying to proof that (::) is applicable to "( \ x : Int . x + 1 ) True":
    Not a single rule matched:
    While trying to intepret the rule TEmptyCtx with ( \ x : Int . x + 1 ) True:
      While trying to proof that (⊢) is applicable to "{}, ( \ x : Int . x + 1 ) True":
        Not a single rule matched:
        While trying to intepret the rule Tnumber with {}, ( \ x : Int . x + 1 ) True:
          n = ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True" is not a "number" but a "e"
        While trying to intepret the rule Tbool with {}, ( \ x : Int . x + 1 ) True:
          b = ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True" is not a "bool" but a "e"
        While trying to intepret the rule TParens with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: "(" e ")" /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule TAscr with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: e "::" T /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule Tx with {}, ( \ x : Int . x + 1 ) True:
          Evaluation contexts only searching within a parse tree and don't handle literals
        While trying to intepret the rule TPlus with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: n1 "+" n2 /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule TIf with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: "If" c "Then" e1 "Else" e2 /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule TLambda with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: "(" "\\" x ":" T1 "." e ")" /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule Tapp with {}, ( \ x : Int . x + 1 ) True:
          While trying to proof that (==) is applicable to "Bool, Int":
            Not a single rule matched:
            While trying to intepret the rule EqBase with Bool, Int:
              Equality predicate not met: T1="Bool" /= "Int"=T2
            While trying to intepret the rule EqArrow with Bool, Int:
              :
                FT: Could not pattern match '"Bool"' over 'Ta1 "->" Tb1'
Property Termination holds for given examples                                   
Property successfull
# Property Termination statisfied with assignment {T --> Bool, e --> True}
  # Predicate satisfied:
  # e :: T
  
    True : bool
    --------------- [Tbool]
    {} ⊢ True, Bool
    ----------------------- [TEmptyCtx]
    True :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
  True : bool
  ----------- [CanonBool]
  (✓) True
  ----------------------- [BigStepCanon]
  True →* True
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Bool, e --> False}
  # Predicate satisfied:
  # e :: T
  
    False : bool
    ---------------- [Tbool]
    {} ⊢ False, Bool
    ------------------------ [TEmptyCtx]
    False :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
  False : bool
  ------------ [CanonBool]
  (✓) False
  ------------------------ [BigStepCanon]
  False →* False
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Bool, e --> If True Then False Else True}
  # Predicate satisfied:
  # e :: T
  
    True : bool                False : bool                True : bool                T1 = Bool = T2
    --------------- [Tbool]    ---------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]
    {} ⊢ True, Bool            {} ⊢ False, Bool            {} ⊢ True, Bool            Bool == Bool
    --------------------------------------------------------------------------------------------------- [TIf]
    {} ⊢ If True Then False Else True, Bool
    --------------------------------------------------------------------------------------------- [TEmptyCtx]
    If True Then False Else True :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
                                                       False : bool
  ------------------------------------ [EvalIfTrue]    ------------ [CanonBool]
  If True Then False Else True → False                 (✓) False
  --------------------------------------------------------------- [BigStepBase]
  If True Then False Else True →* False
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Bool, e --> If ( If True Then False Else True ) Then False Else True}
  # Predicate satisfied:
  # e :: T
  
    True : bool                False : bool                True : bool                T1 = Bool = T2                                                                    
    --------------- [Tbool]    ---------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]                                                           
    {} ⊢ True, Bool            {} ⊢ False, Bool            {} ⊢ True, Bool            Bool == Bool                                                                      
    --------------------------------------------------------------------------------------------------- [TIf]                                                           
    {} ⊢ If True Then False Else True, Bool                                                                      False : bool                True : bool                T1 = Bool = T2
    ----------------------------------------------------------------------------------------------- [TParens]    ---------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]
    {} ⊢ ( If True Then False Else True ), Bool                                                                  {} ⊢ False, Bool            {} ⊢ True, Bool            Bool == Bool
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [TIf]
    {} ⊢ If ( If True Then False Else True ) Then False Else True, Bool
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [TEmptyCtx]
    If ( If True Then False Else True ) Then False Else True :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
                                                                                                                                                                                                                                                 True : bool
                                                                                                            ----------------- [EvalParens]                                                 ------------------------------------ [EvalIfFalse]    ----------- [CanonBool]
                                                                                                            ( False ) → False                                                              If False Then False Else True → True                  (✓) True
  ------------------------------------ [EvalIfTrue]                                                         ----------------------------------------------------------------- [EvalCtx]    --------------------------------------------------------------- [BigStepBase]
  If True Then False Else True → False                                                                      If ( False ) Then False Else True → If False Then False Else True              If False Then False Else True →* True
  -------------------------------------------------------------------------------------------- [EvalCtx]    ----------------------------------------------------------------------------------------------------------------------------------------------- [BigStepRec]
  If ( If True Then False Else True ) Then False Else True → If ( False ) Then False Else True              If ( False ) Then False Else True →* True
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [BigStepRec]
  If ( If True Then False Else True ) Then False Else True →* True
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Int, e --> 42}
  # Predicate satisfied:
  # e :: T
  
    42 : number
    ------------ [Tnumber]
    {} ⊢ 42, Int
    ---------------------- [TEmptyCtx]
    42 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
  42 : number
  ----------- [CanonNumber]
  (✓) 42
  ------------------------- [BigStepCanon]
  42 →* 42
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Int, e --> 1 + 2}
  # Predicate satisfied:
  # e :: T
  
    1 : number               2 : number
    ----------- [Tnumber]    ----------- [Tnumber]
    {} ⊢ 1, Int              {} ⊢ 2, Int
    -------------------------------------- [TPlus]
    {} ⊢ 1 + 2, Int
    ---------------------------------- [TEmptyCtx]
    1 + 2 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
  1 : Number    2 : Number               3 : number
  ------------------------ [EvalPlus]    ---------- [CanonNumber]
  1 + 2 → 3                              (✓) 3
  ------------------------------------------------- [BigStepBase]
  1 + 2 →* 3
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Int, e --> ( \ f : Int -> Int . f 5 ) ( \ i : Int . i + 1 )}
  # Predicate satisfied:
  # e :: T
  
                                                5 : number                                T1 = Int = T2                                           1 : number                         
    ----------------------------------- [Tx]    ---------------------------- [Tnumber]    ------------- [EqBase]    --------------------- [Tx]    --------------------- [Tnumber]    
    f : Int -> Int , {} ⊢ f, Int -> Int         f : Int -> Int , {} ⊢ 5, Int              Int == Int                i : Int , {} ⊢ i, Int         i : Int , {} ⊢ 1, Int              
    ----------------------------------------------------------------------------------------------------- [Tapp]    ----------------------------------------------------- [TPlus]    
    f : Int -> Int , {} ⊢ f 5, Int                                                                                  i : Int , {} ⊢ i + 1, Int                                        T1 = Int -> Int = T2
    -------------------------------------------------------------------------------------------------- [TLambda]    --------------------------------------------------- [TLambda]    ------------------------ [EqBase]
    {} ⊢ ( \ f : Int -> Int . f 5 ), Int -> Int -> Int                                                              {} ⊢ ( \ i : Int . i + 1 ), Int -> Int                           Int -> Int == Int -> Int
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [Tapp]
    {} ⊢ ( \ f : Int -> Int . f 5 ) ( \ i : Int . i + 1 ), Int
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ [TEmptyCtx]
    ( \ f : Int -> Int . f 5 ) ( \ i : Int . i + 1 ) :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
                                                                                                                                             5 : Number    1 : Number               6 : number
                                                                                                                                             ------------------------ [EvalPlus]    ---------- [CanonNumber]
                                                                                                                                             5 + 1 → 6                              (✓) 6
                                                                                             ------------------------------- [EvalLamApp]    ------------------------------------------------- [BigStepBase]
                                                                                             ( \ i : Int . i + 1 ) 5 → 5 + 1                 5 + 1 →* 6
  -------------------------------------------------------------------------- [EvalLamApp]    -------------------------------------------------------------------------------------------------- [BigStepRec]
  ( \ f : Int -> Int . f 5 ) ( \ i : Int . i + 1 ) → ( \ i : Int . i + 1 ) 5                 ( \ i : Int . i + 1 ) 5 →* 6
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [BigStepRec]
  ( \ f : Int -> Int . f 5 ) ( \ i : Int . i + 1 ) →* 6
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Bool, e --> ( True )}
  # Predicate satisfied:
  # e :: T
  
    True : bool
    --------------- [Tbool]
    {} ⊢ True, Bool
    ----------------------- [TParens]
    {} ⊢ ( True ), Bool
    --------------------------------- [TEmptyCtx]
    ( True ) :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
                                  True : bool
  --------------- [EvalParens]    ----------- [CanonBool]
  ( True ) → True                 (✓) True
  ----------------------------------------- [BigStepBase]
  ( True ) →* True
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Bool, e --> False :: Bool}
  # Predicate satisfied:
  # e :: T
  
    False : bool                T1 = Bool = T2
    ---------------- [Tbool]    -------------- [EqBase]
    {} ⊢ False, Bool            Bool == Bool
    ------------------------------------------- [TAscr]
    {} ⊢ False :: Bool, Bool
    --------------------------------------- [TEmptyCtx]
    False :: Bool :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
  False : bool                            False : bool
  --------------------- [EvalAscrBool]    ------------ [CanonBool]
  False :: Bool → False                   (✓) False
  -------------------------------------------------- [BigStepBase]
  False :: Bool →* False
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Bool, e --> ( True )}
  # Predicate satisfied:
  # e :: T
  
    True : bool
    --------------- [Tbool]
    {} ⊢ True, Bool
    ----------------------- [TParens]
    {} ⊢ ( True ), Bool
    --------------------------------- [TEmptyCtx]
    ( True ) :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
                                  True : bool
  --------------- [EvalParens]    ----------- [CanonBool]
  ( True ) → True                 (✓) True
  ----------------------------------------- [BigStepBase]
  ( True ) →* True
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Bool, e --> ( If True Then True Else True ) :: Bool}
  # Predicate satisfied:
  # e :: T
  
    True : bool                True : bool                True : bool                T1 = Bool = T2             
    --------------- [Tbool]    --------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]    
    {} ⊢ True, Bool            {} ⊢ True, Bool            {} ⊢ True, Bool            Bool == Bool               
    -------------------------------------------------------------------------------------------------- [TIf]    
    {} ⊢ If True Then True Else True, Bool                                                                      T1 = Bool = T2
    ---------------------------------------------------------------------------------------------- [TParens]    -------------- [EqBase]
    {} ⊢ ( If True Then True Else True ), Bool                                                                  Bool == Bool
    --------------------------------------------------------------------------------------------------------------------------- [TAscr]
    {} ⊢ ( If True Then True Else True ) :: Bool, Bool
    ----------------------------------------------------------------------------------------------------------------------- [TEmptyCtx]
    ( If True Then True Else True ) :: Bool :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
                                                                                                                       True : bool                           True : bool
                                                                          --------------- [EvalParens]                 ------------------- [EvalAscrBool]    ----------- [CanonBool]
                                                                          ( True ) → True                              True :: Bool → True                   (✓) True
  ---------------------------------- [EvalIfTrue]                         ------------------------------- [EvalCtx]    ----------------------------------------------- [BigStepBase]
  If True Then True Else True → True                                      ( True ) :: Bool → True :: Bool              True :: Bool →* True
  ---------------------------------------------------------- [EvalCtx]    --------------------------------------------------------------------------------------------- [BigStepRec]
  ( If True Then True Else True ) :: Bool → ( True ) :: Bool              ( True ) :: Bool →* True
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------- [BigStepRec]
  ( If True Then True Else True ) :: Bool →* True
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Bool, e --> True}
  # Predicate satisfied:
  # e :: T
  
    True : bool
    --------------- [Tbool]
    {} ⊢ True, Bool
    ----------------------- [TEmptyCtx]
    True :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
  True : bool
  ----------- [CanonBool]
  (✓) True
  ----------------------- [BigStepCanon]
  True →* True
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Bool, e --> ( False )}
  # Predicate satisfied:
  # e :: T
  
    False : bool
    ---------------- [Tbool]
    {} ⊢ False, Bool
    ------------------------ [TParens]
    {} ⊢ ( False ), Bool
    ---------------------------------- [TEmptyCtx]
    ( False ) :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
                                    False : bool
  ----------------- [EvalParens]    ------------ [CanonBool]
  ( False ) → False                 (✓) False
  -------------------------------------------- [BigStepBase]
  ( False ) →* False
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Bool, e --> True :: Bool}
  # Predicate satisfied:
  # e :: T
  
    True : bool                T1 = Bool = T2
    --------------- [Tbool]    -------------- [EqBase]
    {} ⊢ True, Bool            Bool == Bool
    ------------------------------------------ [TAscr]
    {} ⊢ True :: Bool, Bool
    -------------------------------------- [TEmptyCtx]
    True :: Bool :: Bool
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
  True : bool                           True : bool
  ------------------- [EvalAscrBool]    ----------- [CanonBool]
  True :: Bool → True                   (✓) True
  ----------------------------------------------- [BigStepBase]
  True :: Bool →* True
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Int, e --> If True Then 42 Else 43}
  # Predicate satisfied:
  # e :: T
  
    True : bool                42 : number               43 : number               T1 = Int = T2
    --------------- [Tbool]    ------------ [Tnumber]    ------------ [Tnumber]    ------------- [EqBase]
    {} ⊢ True, Bool            {} ⊢ 42, Int              {} ⊢ 43, Int              Int == Int
    ----------------------------------------------------------------------------------------------- [TIf]
    {} ⊢ If True Then 42 Else 43, Int
    ----------------------------------------------------------------------------------------- [TEmptyCtx]
    If True Then 42 Else 43 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
                                               42 : number
  ---------------------------- [EvalIfTrue]    ----------- [CanonNumber]
  If True Then 42 Else 43 → 42                 (✓) 42
  -------------------------------------------------------- [BigStepBase]
  If True Then 42 Else 43 →* 42
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Int, e --> If False Then 23 Else 44}
  # Predicate satisfied:
  # e :: T
  
    False : bool                23 : number               44 : number               T1 = Int = T2
    ---------------- [Tbool]    ------------ [Tnumber]    ------------ [Tnumber]    ------------- [EqBase]
    {} ⊢ False, Bool            {} ⊢ 23, Int              {} ⊢ 44, Int              Int == Int
    ------------------------------------------------------------------------------------------------ [TIf]
    {} ⊢ If False Then 23 Else 44, Int
    ------------------------------------------------------------------------------------------ [TEmptyCtx]
    If False Then 23 Else 44 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
                                                 44 : number
  ----------------------------- [EvalIfFalse]    ----------- [CanonNumber]
  If False Then 23 Else 44 → 44                  (✓) 44
  ---------------------------------------------------------- [BigStepBase]
  If False Then 23 Else 44 →* 44
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Int, e --> 5 + 6}
  # Predicate satisfied:
  # e :: T
  
    5 : number               6 : number
    ----------- [Tnumber]    ----------- [Tnumber]
    {} ⊢ 5, Int              {} ⊢ 6, Int
    -------------------------------------- [TPlus]
    {} ⊢ 5 + 6, Int
    ---------------------------------- [TEmptyCtx]
    5 + 6 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
  5 : Number    6 : Number               11 : number
  ------------------------ [EvalPlus]    ----------- [CanonNumber]
  5 + 6 → 11                             (✓) 11
  -------------------------------------------------- [BigStepBase]
  5 + 6 →* 11
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Int, e --> 5 + 6 + 7}
  # Predicate satisfied:
  # e :: T
  
                             6 : number               7 : number
                             ----------- [Tnumber]    ----------- [Tnumber]
    5 : number               {} ⊢ 6, Int              {} ⊢ 7, Int
    ----------- [Tnumber]    -------------------------------------- [TPlus]
    {} ⊢ 5, Int              {} ⊢ 6 + 7, Int
    --------------------------------------------------------------- [TPlus]
    {} ⊢ 5 + 6 + 7, Int
    ----------------------------------------------------------- [TEmptyCtx]
    5 + 6 + 7 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
  6 : Number    7 : Number               5 : Number    13 : Number               18 : number
  ------------------------ [EvalPlus]    ------------------------- [EvalPlus]    ----------- [CanonNumber]
  6 + 7 → 13                             5 + 13 → 18                             (✓) 18
  ------------------------- [EvalCtx]    --------------------------------------------------- [BigStepBase]
  5 + 6 + 7 → 5 + 13                     5 + 13 →* 18
  ------------------------------------------------------------------------------------------- [BigStepRec]
  5 + 6 + 7 →* 18
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Int, e --> ( \ x : Int . x + 1 ) 5}
  # Predicate satisfied:
  # e :: T
  
                                  1 : number                                                  
    --------------------- [Tx]    --------------------- [Tnumber]                             
    x : Int , {} ⊢ x, Int         x : Int , {} ⊢ 1, Int                                       
    ----------------------------------------------------- [TPlus]                             
    x : Int , {} ⊢ x + 1, Int                                        5 : number               T1 = Int = T2
    --------------------------------------------------- [TLambda]    ----------- [Tnumber]    ------------- [EqBase]
    {} ⊢ ( \ x : Int . x + 1 ), Int -> Int                           {} ⊢ 5, Int              Int == Int
    --------------------------------------------------------------------------------------------------------- [Tapp]
    {} ⊢ ( \ x : Int . x + 1 ) 5, Int
    ---------------------------------------------------------------------------------------------------- [TEmptyCtx]
    ( \ x : Int . x + 1 ) 5 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
                                                  5 : Number    1 : Number               6 : number
                                                  ------------------------ [EvalPlus]    ---------- [CanonNumber]
                                                  5 + 1 → 6                              (✓) 6
  ------------------------------- [EvalLamApp]    ------------------------------------------------- [BigStepBase]
  ( \ x : Int . x + 1 ) 5 → 5 + 1                 5 + 1 →* 6
  -------------------------------------------------------------------------------------------------- [BigStepRec]
  ( \ x : Int . x + 1 ) 5 →* 6
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Int, e --> If ( If True Then False Else True ) Then 123456 Else 42}
  # Predicate satisfied:
  # e :: T
  
    True : bool                False : bool                True : bool                T1 = Bool = T2                                                                     
    --------------- [Tbool]    ---------------- [Tbool]    --------------- [Tbool]    -------------- [EqBase]                                                            
    {} ⊢ True, Bool            {} ⊢ False, Bool            {} ⊢ True, Bool            Bool == Bool                                                                       
    --------------------------------------------------------------------------------------------------- [TIf]                                                            
    {} ⊢ If True Then False Else True, Bool                                                                      123456 : number               42 : number               T1 = Int = T2
    ----------------------------------------------------------------------------------------------- [TParens]    ---------------- [Tnumber]    ------------ [Tnumber]    ------------- [EqBase]
    {} ⊢ ( If True Then False Else True ), Bool                                                                  {} ⊢ 123456, Int              {} ⊢ 42, Int              Int == Int
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [TIf]
    {} ⊢ If ( If True Then False Else True ) Then 123456 Else 42, Int
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [TEmptyCtx]
    If ( If True Then False Else True ) Then 123456 Else 42 :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
                                                                                                                                                                                                                                          42 : number
                                                                                                          ----------------- [EvalParens]                                               --------------------------------- [EvalIfFalse]    ----------- [CanonNumber]
                                                                                                          ( False ) → False                                                            If False Then 123456 Else 42 → 42                  (✓) 42
  ------------------------------------ [EvalIfTrue]                                                       --------------------------------------------------------------- [EvalCtx]    -------------------------------------------------------------- [BigStepBase]
  If True Then False Else True → False                                                                    If ( False ) Then 123456 Else 42 → If False Then 123456 Else 42              If False Then 123456 Else 42 →* 42
  ------------------------------------------------------------------------------------------ [EvalCtx]    -------------------------------------------------------------------------------------------------------------------------------------------- [BigStepRec]
  If ( If True Then False Else True ) Then 123456 Else 42 → If ( False ) Then 123456 Else 42              If ( False ) Then 123456 Else 42 →* 42
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [BigStepRec]
  If ( If True Then False Else True ) Then 123456 Else 42 →* 42
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Int, e --> 5 + ( 6 + 7 )}
  # Predicate satisfied:
  # e :: T
  
                             6 : number               7 : number
                             ----------- [Tnumber]    ----------- [Tnumber]
                             {} ⊢ 6, Int              {} ⊢ 7, Int
                             -------------------------------------- [TPlus]
    5 : number               {} ⊢ 6 + 7, Int
    ----------- [Tnumber]    ------------------------------------ [TParens]
    {} ⊢ 5, Int              {} ⊢ ( 6 + 7 ), Int
    --------------------------------------------------------------- [TPlus]
    {} ⊢ 5 + ( 6 + 7 ), Int
    ----------------------------------------------------------- [TEmptyCtx]
    5 + ( 6 + 7 ) :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
                                                                               5 : Number    13 : Number               18 : number
                                         ----------- [EvalParens]              ------------------------- [EvalPlus]    ----------- [CanonNumber]
  6 : Number    7 : Number               ( 13 ) → 13                           5 + 13 → 18                             (✓) 18
  ------------------------ [EvalPlus]    ------------------------ [EvalCtx]    --------------------------------------------------- [BigStepBase]
  6 + 7 → 13                             5 + ( 13 ) → 5 + 13                   5 + 13 →* 18
  ------------------------- [EvalCtx]    ------------------------------------------------------------------------------------------ [BigStepRec]
  5 + ( 6 + 7 ) → 5 + ( 13 )             5 + ( 13 ) →* 18
  --------------------------------------------------------------------------------------------------------------------------------- [BigStepRec]
  5 + ( 6 + 7 ) →* 18
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Int, e --> ( 5 + 6 ) + ( 7 + 8 )}
  # Predicate satisfied:
  # e :: T
  
    5 : number               6 : number               7 : number               8 : number
    ----------- [Tnumber]    ----------- [Tnumber]    ----------- [Tnumber]    ----------- [Tnumber]
    {} ⊢ 5, Int              {} ⊢ 6, Int              {} ⊢ 7, Int              {} ⊢ 8, Int
    -------------------------------------- [TPlus]    -------------------------------------- [TPlus]
    {} ⊢ 5 + 6, Int                                   {} ⊢ 7 + 8, Int
    ------------------------------------ [TParens]    ------------------------------------ [TParens]
    {} ⊢ ( 5 + 6 ), Int                               {} ⊢ ( 7 + 8 ), Int
    ---------------------------------------------------------------------------------------- [TPlus]
    {} ⊢ ( 5 + 6 ) + ( 7 + 8 ), Int
    ------------------------------------------------------------------------------------ [TEmptyCtx]
    ( 5 + 6 ) + ( 7 + 8 ) :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
                                                                                                                                                                                        11 : Number    15 : Number               26 : number
                                                                                                                                                  ----------- [EvalParens]              -------------------------- [EvalPlus]    ----------- [CanonNumber]
                                                                                                           7 : Number    8 : Number               ( 15 ) → 15                           11 + 15 → 26                             (✓) 26
                                                                                                           ------------------------ [EvalPlus]    ------------------------ [EvalCtx]    ---------------------------------------------------- [BigStepBase]
                                                                                                           7 + 8 → 15                             11 + ( 15 ) → 11 + 15                 11 + 15 →* 26
                                                          ----------- [EvalParens]                         ------------------------- [EvalCtx]    ------------------------------------------------------------------------------------------- [BigStepRec]
  5 : Number    6 : Number                                ( 11 ) → 11                                      11 + ( 7 + 8 ) → 11 + ( 15 )           11 + ( 15 ) →* 26
  ------------------------ [EvalPlus]                     ----------------------------------- [EvalCtx]    ---------------------------------------------------------------------------------------------------------------------------------- [BigStepRec]
  5 + 6 → 11                                              ( 11 ) + ( 7 + 8 ) → 11 + ( 7 + 8 )              11 + ( 7 + 8 ) →* 26
  ------------------------------------------ [EvalCtx]    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [BigStepRec]
  ( 5 + 6 ) + ( 7 + 8 ) → ( 11 ) + ( 7 + 8 )              ( 11 ) + ( 7 + 8 ) →* 26
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [BigStepRec]
  ( 5 + 6 ) + ( 7 + 8 ) →* 26
  
  
Property successfull
# Property Termination statisfied with assignment {T --> Int, e --> 5 + ( 6 + ( 7 + 8 ) )}
  # Predicate satisfied:
  # e :: T
  
                                                      7 : number               8 : number
                                                      ----------- [Tnumber]    ----------- [Tnumber]
                                                      {} ⊢ 7, Int              {} ⊢ 8, Int
                                                      -------------------------------------- [TPlus]
                             6 : number               {} ⊢ 7 + 8, Int
                             ----------- [Tnumber]    ------------------------------------ [TParens]
                             {} ⊢ 6, Int              {} ⊢ ( 7 + 8 ), Int
                             --------------------------------------------------------------- [TPlus]
    5 : number               {} ⊢ 6 + ( 7 + 8 ), Int
    ----------- [Tnumber]    ------------------------------------------------------------- [TParens]
    {} ⊢ 5, Int              {} ⊢ ( 6 + ( 7 + 8 ) ), Int
    ---------------------------------------------------------------------------------------- [TPlus]
    {} ⊢ 5 + ( 6 + ( 7 + 8 ) ), Int
    ------------------------------------------------------------------------------------ [TEmptyCtx]
    5 + ( 6 + ( 7 + 8 ) ) :: Int
  
  
  
  # Satisfies a possible conclusion:
  # e →* v
  
                                                                                                                                                                                         5 : Number    21 : Number               26 : number
                                                                                                                                                   ----------- [EvalParens]              ------------------------- [EvalPlus]    ----------- [CanonNumber]
                                                                                                           6 : Number    15 : Number               ( 21 ) → 21                           5 + 21 → 26                             (✓) 26
                                                                                                           ------------------------- [EvalPlus]    ------------------------ [EvalCtx]    --------------------------------------------------- [BigStepBase]
                                                                                                           6 + 15 → 21                             5 + ( 21 ) → 5 + 21                   5 + 21 →* 26
                                                          ----------- [EvalParens]                         -------------------------- [EvalCtx]    ------------------------------------------------------------------------------------------ [BigStepRec]
  7 : Number    8 : Number                                ( 15 ) → 15                                      5 + ( 6 + 15 ) → 5 + ( 21 )             5 + ( 21 ) →* 26
  ------------------------ [EvalPlus]                     ----------------------------------- [EvalCtx]    ---------------------------------------------------------------------------------------------------------------------------------- [BigStepRec]
  7 + 8 → 15                                              5 + ( 6 + ( 15 ) ) → 5 + ( 6 + 15 )              5 + ( 6 + 15 ) →* 26
  ------------------------------------------ [EvalCtx]    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [BigStepRec]
  5 + ( 6 + ( 7 + 8 ) ) → 5 + ( 6 + ( 15 ) )              5 + ( 6 + ( 15 ) ) →* 26
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [BigStepRec]
  5 + ( 6 + ( 7 + 8 ) ) →* 26
  
  
Property successfull
# Property Termination proven by failing predicate with assignment {e --> ( \ x : Int . x + 1 ) True}:
  # Failed: e :: T
# e :: T failed because: 
  While trying to proof that (::) is applicable to "( \ x : Int . x + 1 ) True":
    Not a single rule matched:
    While trying to intepret the rule TEmptyCtx with ( \ x : Int . x + 1 ) True:
      While trying to proof that (⊢) is applicable to "{}, ( \ x : Int . x + 1 ) True":
        Not a single rule matched:
        While trying to intepret the rule Tnumber with {}, ( \ x : Int . x + 1 ) True:
          n = ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True" is not a "number" but a "e"
        While trying to intepret the rule Tbool with {}, ( \ x : Int . x + 1 ) True:
          b = ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True" is not a "bool" but a "e"
        While trying to intepret the rule TParens with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: "(" e ")" /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule TAscr with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: e "::" T /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule Tx with {}, ( \ x : Int . x + 1 ) True:
          Evaluation contexts only searching within a parse tree and don't handle literals
        While trying to intepret the rule TPlus with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: n1 "+" n2 /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule TIf with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: "If" c "Then" e1 "Else" e2 /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule TLambda with {}, ( \ x : Int . x + 1 ) True:
          Sequence lengths are not the same: "(" "\\" x ":" T1 "." e ")" /= ("(" "\\" "x" ":" "Int" "." ("x" "+" 1) ")") "True"
        While trying to intepret the rule Tapp with {}, ( \ x : Int . x + 1 ) True:
          While trying to proof that (==) is applicable to "Bool, Int":
            Not a single rule matched:
            While trying to intepret the rule EqBase with Bool, Int:
              Equality predicate not met: T1="Bool" /= "Int"=T2
            While trying to intepret the rule EqArrow with Bool, Int:
              :
                FT: Could not pattern match '"Bool"' over 'Ta1 "->" Tb1'
