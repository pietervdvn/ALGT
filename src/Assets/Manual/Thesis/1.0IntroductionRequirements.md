
 Building and Gradualizing Programming Languages
=================================================


Computers are complicated machines. A modern CPU (anno 2017) contains over _2 billion_ transistors and flips states over _3 billion_ times a second \cite{Intel}. Controlling these machines is hard; controlling them with low-level assembly has been an impossible task for decades. Luckily, higher level programming languages have been created to ease this task.


However, creating such programming languages is a hard task too. Aside from the technical aspect of executing a program in such a language on a specific machine, languages should be formally correct and strive to minimize errors made by the human programmer, preferably without hindering creating usefull programs. This is a huge task; several approaches to solve this complex problem have been tried, all with their own trade-offs such as the usage of a typecheckers, amongst other choices.
Another hindrance for the programming language field is the lack of common jargon and tools supporting programming language design. 


