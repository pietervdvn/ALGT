
 Abstracting Gradual Typing
----------------------------

As seen in the previous intuitive approach, both the typechecker and the runtime should be modified: the typechecker should be able to handle the missing type information, the runtime should detect when type errors occur.

It turns out that a static typesystem and language can be converted algorithmically into a gradual typesystem and accompanying runtime. This result is presented by Ronald Garcia, Alison M. Clark and Ã‰ric Tanter in their paper _Abstracting Gradual Typing_\cite{GarciaAGT}.

The AGT approach is an interplay of multiple components:

- The staticly typed language with its typechecker, which acts as input.
- A gradualized typechecker, which is constructed algorithmically.
- A runtime with intrinsic terms, carrying evidence


### The proposed dynamic runtime

The AGT-paper presents a runtime, in which each expression carries its typing information with it (intrinsic terms). These intrinsic terms carry the type of the expression and some evidence that their typing might hold; some evidence that the missing type information will work out.

Reduction of an intrinsic term not only involves reducing the actual expression, but also evolving the typing information. The typing of the expression itself does not change, but the evidence that the typing might hold should evolve to new evidence which proofs typing for the newly obtained term or crash the program if the evidence can not be evolved due to a typing error that is discovered.

Furthermore, the paper presents a way to construct the algorithm calculating the initial evidence for an expression, called the _interior_.

### Simplifying the runtime

While the mathematics to achieve this are impressive, they are somewhat overengineerd. Having an algorithm available to calculate the evidence for a term, implies that at each reduction step, the evidence can simply be recalculated instead of evolved. This makes the implementation easier, at the cost of elegance.
However, this simplification can be taken further. The major goal of this evidence is proving that the typing (still) holds at a given moment in the execution. By removing the evolution of evidence, the purpose of constructing explicit evidence itself is gone. Instead of constructing evidence using interiors, the gradual typechecker itself can be run. If this typechecker succeeds, the expression is valid and can be reduced at least once more. If the typechecker fails, a type error can be generated.

Note that the typechecker will only fail iff the expression can not be evaluated any further: when no reduction rule can be applied, due to a type error, no typing rule will be applicable as well - because the typechecker structure mimicks the reduction structure. So, when an expression should be reduced and it is unclear if the typing still holds, simply trying to reduce the expression suffices. If reduction fails, an error message should be provided - either the implicit error message generated by ALGT, or an explicit bottom element incorporated in the language.

The drawback of this approach is that the reduction relation should be constructed as a dynamic runtime from the start, incorporating dynamic features such as casts and eventually a type error element. To perform these casts, the implementor is free to chose between two possible implementations: carrying around type information in the term (having a slight runtime memory cost) or calculating the type of an expression when needed (which is free for call by value languages).

At last, some care should be taken constructing the dynamic reduction relation, that no untyped data can slipped into a typed part of the code. This can be done inserting casts when necessary.

In conclusion, to gradualize a programming language, the ingredients needed are:

- A programming language definition (the syntax)
- A reduction relation supporting a dynamic runtime (eventually implicitly)
- A static typechecker

Gradualizing these involves mainly modifying the typechecker. The syntax itself only needs a minimal modification.



