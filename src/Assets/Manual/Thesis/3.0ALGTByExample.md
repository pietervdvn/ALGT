Creating STFL in ALGT
=====================

Now that the design goals are clear, we present **ALGT**, a tool and language to describe both syntax and semantics of aribitrary programming languages.
This can be used to formally capture meaning of any language, formalizing them or, perhaps, gradualize them. 

To introduce the ALGT-language, a small functional language (STFL) is formalized, as to give a clear yet practical overview. When necessary, some key algorithms are presented (such as the typechecker).
This chapter does _not_ give an overview of the used command line arguments, exhaustive overview of builtin functions, ... For this, we refer the reader to the tutorial and manual, which can be obtained by running `ALGT --manual-pdf`.

STFL
----

The _Simply Typed Functional Language_ (STFL) is a small, functional language supporting integers, addition, booleans, if-then-else constructions and lambda expressions, as visible in the examples. Furthermore, it is strongly typed, with booleans, integers and higher-order functions.

STFL is the smallest language featuring a typechecker. Due to its simplicity, it is widely used as example language in the field and thus well-understood throughout the community. This language will be gradualized in a later chapter. 


Expression						End result
----------						----------
`1`							`1`
`True`							`True`
`If True Then 0 Else 1`					`0`
`41 + 1`						`42`
`(\x : Int . x + 1) 41`					`42`
`(\f : Int -> Int . f 41) (\x : Int -> Int . x + 1) `	`42`


 Skeleton
----------

A language is defined in a single `.language`-document, which is split in multiple sections: one for each aspect of the programming language. Each of these sections will be explored in depth.

	STFL # Name of the language	
	****

	Syntax
	======

	# Syntax definitions

	Functions
	=========

	# Rewriting rules, small helper functions

	Relations
	=========

	# Declarations of which symbols are used

	Rules
	=====

	# Natural deduction rules, defining operational semantics or typechecker

	Properties
	==========

	# Automaticly checked properties


Syntax
------

The first step in formalizing a language is declaring a parser, which will turn the source code into a parsetree. In order to do so, we declare a context-free grammer, denoted as BNF, in order to construct a parser.

A context-free grammer can be used for two goals: the first is creating all possible string a language contains. On the other hand, we might use this grammer to deduce wether a given string is part of the language - and if it is, how this string is structured. This latter process is called _parsing_. 

### BNF

When formalizing a language syntax, the goal is to capture all possible strings that the a program could be. This can be done with **production rules**. A production rule captures a _syntactic form_ and consists of a name, followed by on or more options. 
An option is a sequence of literals or the name of another syntactic form:

	nameOfRule	::= otherForm | "literal" | otherForm "literal" otherForm1 | ...


The syntactic form (or language) containing all boolean constants, can be captured with:

	bool		::= "True" | "False"

A language containing all integers has already been provided via a builtin:

	int		::= Number

The syntactic form containing all additions of two terms can now easily be captured:

	addition	::= int "+" int

Syntactic forms can be declared recursively as well, to declare more complex additions:

	addition	::= int "+" addition

Note that some syntactic forms are not allowed (such as empty syntactic forms or left recursive forms), this is more detailed in the section [syntax-properties]

### STFL-syntax

In this format, the entire syntax for STFL can be formalized. 

The first syntactic forms defined are types. Types are split into typeTerms and function types:

$$$stfl.language![14..15]!file

The builtin constants `True` and `False` are defined as earlier introduced:

$$$stfl.language!9!file


For integers and variables, the corresponding builtin values are used: 

$$$stfl.language![19..20]!file

`number` and `bool` together form `value`, the expressions which are in their most simple and canonical form:

$$$stfl.language![19..21]!file


Expressions are split into terms (`eL`) and full expressions (`e`):

$$$stfl.language![23..32]!file


A typing environment is provided as well. This is not part of the language itself, but will be used when typing variables:


$$$stfl.language![38..39]!file



### Parsing

Parsing is the process of structuring an input string, to construct a parsetree.
This is the first step in any compilation or interpretation process.

The parser in ALGT is a straightforward recursive descent parser, constructed dynamically by interpreting the syntax definition, of which the inner workings are detailed below.

When a string is parsed against syntactic form, the options in the definition of the syntactic form are tried, from left to right. The first option matching the string will be used. An option, which is a sequence of either literals or other syntactic forms, is parsed by parsing element per element. A literal is parsed by comparing the head of the string to the literal itself, syntactic forms are parsed recursively.

In the case of `20 + 22` being parsed against `expr`, all the choices defining `expr` are tried, being `term "+" expr`, `term expr` and `term`. As parsing happens left to right, first `term "+" expr` is tried. In order to do so, first `term` is parsed against the string. 
After inspecting all the choices for term, the parser will use the last choice of term (`int`), which neatly matches `22`.
The string left is `+ 22`, which should be parsed against the rest of the sequence, `"+" expr`. The `"+"` in the sequence is now next to be parsed, which matches the head of the string. The last `22` is parsed against `expr`. In order to parser `22`, the last choice of `expr` is used.

A part of this process is denoted here, where the leftmost element of the stack is parsed:

	Resting string	  stack
	--------------	  -----

	"20 + 22"	~ expr
	"20 + 22"	~ expr.0 (term "+" expr)
	"20 + 22"	~ term ; expr.0 ("+" expr)
	"20 + 22"	~ term.0 ("If" expr ...) ; expr.0 ("+" expr)
	"20 + 22"	~ term.1 ("(" "\" var ":" ...) ; expr.0 ("+" expr)
	"20 + 22"	~ term.2 (bool) ; expr.0 ("+" expr)
	"20 + 22"	~ bool ; term.2 (bool) ; expr.0 ("+" expr)
	"20 + 22"	~ bool.0 ("True") ; term.2 (bool) ; expr.0 ("+" expr)
	"20 + 22"	~ bool.1 ("False") ; term.2 (bool) ; expr.0 ("+" expr)
	"20 + 22"	~ term.3 (int) ; expr.0 ("+" expr)
	"+ 22"		~ expr.0 ("+" expr)
	"22"		~ expr.0 (expr)
	"22"		~ expr; expr.0 ()
	...
	"22"		~ term.3 (int) ; expr.2 (); expr.0 ()


![Parsetree of `20 + 22`](Parsetree6_0.png)

![Parsetree of a function type](Parsetree0_0.png)


### Conclusion

ALGT allows a concise yet accurate description of any language, through the use of BNF. This notation can then be interpreted in order to parse a target program file; resulting in the parsetree. 


Metafunctions
-------------

Existing parsetrees can be modified or rewritten by using **metafunctions**[^termFunction]. A metafunction receives one or more parsetrees as input and generates a new parsetree based on that.

[^termFunction]: In this section, we will also use the term _function_ to denote a _metafunction_. Under no condition, the term function refers to some entity of the target language.

Metafunctions have the following form:

	f	: input1 -> input2 -> ... -> output
	f(pattern1, pattern2, ...)	= someParseTree
	f(pattern1', pattern2', ...)	= someParseTree'


The obligatory **signature** gives the name (`f`), followed by what syntactic forms the input parsetrees should have. The last element of the type[^syntacticType] signature is the syntactic form of the parsetree that the function should return. ALGT effectivily _typechecks_ functions, thus preventing the construction of parsetrees for which no syntactic form is defined.


[^syntacticType]: In this chapter, the term _type_ is to be read as _the syntactic form a parsetree has_. It has nothing to do with the types defined in STFL. Types as defined within STFL will be denoted with `type`.

The body of the functions consists of one or more **clauses**, containing one pattern for each input argument and an expression to construct the resulting parsetree.

**Patterns** have multiple purposes:

- First, they act as guard: if the input parsetree does not have the right form or contents, the match fails and the next clause in the function is activated.
- Second, they assign variables, which can be used to construct a new parsetree.
- Third, they can deconstruct large parsetrees, allowing finegrained pattern matching withing the parsetrees branches.
- Fourth, advanced searching behaviour is implemented in the form of evaluation contexts.


**Expressions** are the dual of patterns: where a pattern deconstructs, the expression does construct a parsetree; where the pattern assigns a variable, the expression will recall the variables value. Expressions are used on the right hand side of each clause, constructing the end result of the value.

An overview of all patterns and expressions can be seen in the following tables:



| Expr				| As pattern			
|:------------------------------|:---------------------------------------------
$$$patternExamples


| Expr			| Name		|  As expression						
|:----------------------|:--------------|:-------------------------------------
$$$expressionExamples


### Domain and codomain

With these expressions and patterns, it is possible to make a metafunction extracting the domain and codomain of a function `type` (in STFL). These will be used in the typechecker later. `domain` and `codomain` are defined in the following way:

$$$STFL.language![30..42]!file


Recall the parsetree generated by parsing `Int -> Bool` against `type`. If this parsetree were used as input into the `domain` function, it would fail to match the first pattern (as the parsetree does not contain parentheses) nor would it match the second pattern (again are parentheses needed). The third pattern matches, by assigning `T1` and `T2`, as can seen in figure \ref{fig:patternMatch1}. `T1` is extracted and returned by `domain`, which is, by definition the domain of the `type`.

\begin{figure}
\center
\includegraphics{TypeTrees0annot.png}
\caption{Pattern matching of \code{Int -> Bool}}
\label{fig:patternMatch1}
\end{figure}

Analogously, the more advanced parsetree representing `Int -> Bool -> Bool` will be deconstructed the same way, as visible in figure \ref{fig:patternMatch2}, again capturing the domain withing `T1`.


\begin{figure}
\center
\includegraphics{TypeTrees1annot.png}
\caption{Pattern matching of \code{Int -> Bool -> Bool}}
\label{fig:patternMatch2}
\end{figure}


The deconstructing behaviour of patterns can be observed when `(Int -> Bool) -> Bool` is used as argument for `domain`. It matches the second clause, deconstructing the part left of the arrow (`(Int -> Bool)`) and matching it against the embedded pattern `"(" T1 ")"`, as visualised in figure \ref{fig:patternMatch3}, capturing the domain _without parentheses_ in `T1`.

\begin{figure}
\center
\includegraphics{TypeTrees2annot1.png}
\caption{Pattern matching of \code{(Int -> Bool) -> Bool}. Matching in the subpattern is denoted with green}
\label{fig:patternMatch3}
\end{figure}


### Conclusion

Metafunctions give a concise, typesafe way to transform parsetrees. The many checks, such as wrong types, liveness and fallthrough perform the first sanity checks and catch many bugs beforehand.

%% TODO Link
Readers interested in the actual typechecking of metafunctions, are referred to the chapter about internals; the checks catching liveness and fallthrough are explained in the chapter about abstract interpretation.




