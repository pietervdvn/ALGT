### Typechecker

A typechecker checks expressions for constructions which don't make sense, such as `1 + True`. This is tremendously usefull to catch errors in a static way, before even running the program.

In this part, a typechecker for STFL is constructed, using the same notation as introduced in the previous part. Just like the relation `→`, which related two expressions, a relation `::` is defined which relates expression to its type. The relation `::` is thus a relation in `expr × type`.

Examples of elements in this relation are:

expression		type
----------		----
`True`			`Bool`
`If True Then 0 Else 1`	`Int`
`(\ x : Int . x + 1)`	`Int -> Int`
`1 + 1`			`Int`
`1 + True`		_undefined, type error_

However, this relation can't handle variables. When a variable is declared, its type should be saved somehow and passed as argument with the relation.
Saving the types of declared variables is done by keeping a **typing environment**, which is a syntacical form acting as list. As a reminder, it is defined as:

$$$stfl.language!38,39!file

A new relation `(⊢)` is introduced takes, apart from the expression, a typing environment as well to deduce the type of an expression. Some example elements in this relation are:

expression		Typing environment		type
----------		------------------		----
`True`			`{}`				`Bool`
`x`			`x : Bool, {}`			`Bool`
`If True Then 0 Else 1`	`x : Bool, {}`			`Int`
`(\ x : Int . x + 1)`	`{}`				`Int -> Int`
`1 + 1`			`y : Int, {}`			`Int`
`1 + True`		`{}`				_undefined, type error_


### Declaration of :: and ⊢

Just like defining the semantics, we begin by declaring the relations.

Both `::` and `⊢` have an `expr` and a `type` argument. In both cases, `expr` can't be of mode `out`, as an infinite number of expressions exist of any given type. On the other hand, each given expression can only have one corresponding type, so the `type`-argument can be of mode `out`. The typing environment argument is has mode `out` just as well; as infinite many typing environments might lead to a correct typing, namely all environments containing unrelated variables.

The actual declaration thus is as following:

$$$stfl.language!116,118!file

### Definition of ::


As `::` is essentialy the same as `⊢` with an empty type environment, `::` is defined in terms of `⊢`. The expression argument is passed to `⊢`, together with the empty type environment `{}`:


$$$stfl.language![188..190]!file


### Definition of ⊢

The heavy lifting is done by `⊢`, which will try to deduce a type for each syntacic concstruction, resulting in a single natural deduction rule for each of them.
As a reminder, the following syntacic forms exist in STFL and are typed:

- Booleans
- Integers
- Expressions within parens
- Addition
- If-expressions
- Type ascription
- Variables
- Lambda abstractions
- Function application

Each of these will get a typing rule in the following paragraphs. In these rules, `Γ` will always denote the typing environment. Checking types for equality is done with a custom equality relation `==`, as this relation will be replaced by `~` in the gradualization step. `==` is defined in a straightforward way and can be replaced by `=` if needed.

#### Typing booleans

Basic booleans, such as `True` and `False` can be typed right away:

$$$stfl.language![200..202]!file

Here, `Γ` denotes the typing environment (which is not used in this rule); `b` is the expression and `"Bool"` is the type of that expression. In order to force that `b` is only `"True"` or `"False"`, the predicate `b:bool` is used.

#### Typing integers

The rule typing integers is completely analogously:

$$$stfl.language![196..198]!file

#### Typing parens

When an expression of the form `(e)` should be typed, the type of the whole is the same as the type of the enclosed expression. This can be expressed as a rule tying these elements together:

$$$stfl.language![206..208]!file

#### Typing addition

Just like a number, an addition is always an `Int`. There is a catch though, namely that both arguments should be `Int` too. This is stated in the predicates of the rule:

$$$stfl.language![221..223]!file

#### Typing if

A functional `If`-expression has the type of the expression it might return. This introduces a constraint: namely that the expression in the if-branch has the same type as the expression in the else-branch. Furthermore, the condition should be a boolean, resulting in the three predicates of the rule:

$$$stfl.language![226..228]!file

#### Type ascription

Typing a type ascription boils down to typing the nested expression and checking that the nested expression has the same type as is asserted:

$$$stfl.language![211..213]!file


#### Variables

Variables are typed by searching the corresponding typing in the typing environment. This searching is implemented by the evaluation context, as `Γ[x ":" T]` will search a subtree matching a variable named `x` in the store. When found, the type of `x` will be bound in `T`:

$$$stfl.language![217..218]!file

These variable typings are introduced in the environment by lambda expressions.


#### Lambda abstractions

The type of a lambda expression is the function type, with domain the type of the argument and codomain the type of the body.

The type of the argument is explicitly given and can be immediatly used. The type of the body should be calculated, which is done in the predicate. Note that the typing of the body considers the newly introduced variable, by appending it into the typing environment:

$$$stfl.language![232..234]!file

#### Function application

The last syntacic form to type is function application. In order to type an application, both the function and argument are typed in the predicates.
To obtain the type of an application, the codomain of the function type is used. Luckily, we introduced a helper function earlier which calculates exactly this. At last, we check that the argument is of the expected type, namely the domain of the function.

This results in the following rule:

$$$stfl.language![238..240]!file

#### Overview

These ten natural deduction rules describe the entire typechecker. For reference, they are all stated here together with the definition of the convenience relation `::` :

$$$stfl.language![188..240]!file

With these rules, the expressions which were evaluated in the previous chapter, can be typed. The proofs leading to their typing, are given below:

$$$($$$stfl.language $$$Examples.stfl!7 -l e -r :: --nc --short-proofs 1)

$$$($$$stfl.language $$$Examples.stfl!8 -l e -r :: --nc --short-proofs 1)


